import { useState } from "react";
import { type GetStaticPropsContext } from "next";
import Head from "next/head";
import { useRouter } from "next/router";

import { createServerSideHelpers } from "@trpc/react-query/server";
import toast from "react-hot-toast";
import superjson from "superjson";

import WithNavBar from "~/components/UI/with-nabvar";
import RecipeDetails, {
  DetailsPageType,
} from "~/components/recipe/recipe-details";
import RecipeForm from "~/components/recipe/recipe-form";
import { prisma } from "~/server/db";
import { type RecipeFormModel, type Recipe } from "~/models/recipe";
import { appRouter } from "~/server/api/root";
import { useRecipe } from "~/hooks/data/recipe";

export default function Recipe({ id }: { id: string }) {
  const router = useRouter();

  const [pageType, setPageType] = useState(DetailsPageType.Details);

  const {
    recipe,
    isLoading,
    update,
    delete: deleteRecipe,
    favorite,
    categories,
    allIngredients,
  } = useRecipe(id);

  const pageTypeHandler = () => {
    setPageType((prevType) =>
      prevType === DetailsPageType.Details
        ? DetailsPageType.Edit
        : DetailsPageType.Details,
    );
  };

  const onUpdate = async (recipeToUpdate: RecipeFormModel) => {
    if (!recipeToUpdate?.id || !recipeToUpdate?.name || !recipe?.author.id) {
      setPageType(DetailsPageType.Details);
      return;
    }

    const updateRecipe = update(recipeToUpdate, recipe.author.id, () => {
      setPageType(DetailsPageType.Details);
      window.scrollTo({ top: 0 });
    });

    await toast.promise(updateRecipe, {
      error: "Failed to update",
      loading: "Updating recipe",
      success: "Updated recipe",
    });
  };

  const cancelHandler = () => {
    setPageType(DetailsPageType.Details);
  };

  const favoriteHandler = async (favorited: boolean) => {
    if (!recipe) return;
    const favoriteAsync = favorite(
      recipe.recipe.id,
      recipe.author.id,
      favorited,
    );
    await toast.promise(favoriteAsync, {
      error: "Failed to update",
      loading: "Updating recipe",
      success: "Updated recipe",
    });
  };

  const deleteHandler = async () => {
    if (!recipe?.recipe?.id || !recipe?.author?.id) {
      toast.error("Invalid recipe");
      return;
    }

    const asyncDelete = deleteRecipe(
      recipe.recipe.id,
      recipe.author.id,
      async () => {
        await router.push("/");
      },
    );

    await toast.promise(asyncDelete, {
      error: "Failed to delete",
      loading: "Deleting recipe",
      success: "Deleted recipe",
    });
  };

  return (
    <>
      <Head>
        <title>Recipe Details</title>
        <meta name="description" content="Generated by create-t3-app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <WithNavBar>
        <main className="flex w-full flex-col">
          <div className="container flex w-full flex-col items-center justify-center gap-12 py-8 md:py-16">
            <div className="flex w-full flex-col items-center gap-2">
              <>
                {recipe && !isLoading && (
                  <>
                    {pageType === DetailsPageType.Details && (
                      <RecipeDetails
                        author={recipe.author}
                        recipe={recipe.recipe}
                        pageTypeHandler={pageTypeHandler}
                        onDelete={deleteHandler}
                        onFavorite={favoriteHandler}
                      />
                    )}
                    {pageType === DetailsPageType.Edit && (
                      <RecipeForm
                        allIngredients={allIngredients}
                        categories={categories}
                        recipe={recipe.recipe}
                        isLoading={isLoading}
                        onSubmit={onUpdate}
                        onCancel={cancelHandler}
                      />
                    )}
                  </>
                )}
              </>
            </div>
          </div>
        </main>
      </WithNavBar>
    </>
  );
}

export async function getStaticPaths({}: GetStaticPropsContext) {
  const helpers = createServerSideHelpers({
    router: appRouter,
    ctx: { session: null, prisma },
    transformer: superjson,
  });

  // Can we avoid using trpc here?
  const recipes = await helpers.recipes.getAll.fetch({ max: 10 });
  const paths = recipes.map((recipe) => ({ params: { id: recipe.id } }));

  return {
    paths,
    fallback: "blocking",
  };
}

export async function getStaticProps(
  context: GetStaticPropsContext<{ id: string }>,
) {
  const helpers = createServerSideHelpers({
    router: appRouter,
    ctx: { session: null, prisma },
    transformer: superjson,
  });

  // Can we avoid using trpc here?
  const id = context.params?.id ?? "";
  await helpers.recipes.getDetails.prefetch({ id });

  return {
    props: {
      trpcState: helpers.dehydrate(),
      id,
    },
    revalidate: 10,
  };
}
